{"ast":null,"code":"import { createStore, combineReducers, applyMiddleware } from \"redux\"; // applyMiddleware 是 redux 的中间件，构建一些第三方的一些扩展 redux 整个应用体系的方法。\n\nimport ReduxThunk from \"redux-thunk\";\nconst allReducers = combineReducers({\n  user: userReducer\n}); // 注意这里的 state 也会发生变化，会自动帮我进行模块区分 { count:initalState, user:userInitialState }\n\nconst store = createStore(allReducers, {\n  count: initalState,\n  user: userInitialState\n}, applyMiddleware(ReduxThunk)); // console.log(store.getState());\n// action creatore - 有些 action 我们传输的内容会比较多，每次去申明对象，显示这个 type 会比较麻烦，写一个 function 来传递一些参数进去会比较方便一些.\n// 通过这样的方式，让服务端渲染的过程当中，通过调用这个方法来重新生成这个 store，使得每次这个 store 对象都是新的\n\nexport default function initialzeStore(state) {\n  const store = createStore(allReducers, Object.assign({}, {\n    count: initalState,\n    user: userInitialState\n  }, state), applyMiddleware(ReduxThunk));\n  return store;\n}","map":{"version":3,"sources":["C:/Users/pc/Desktop/慕课学习/nextjs-create-app/store/store.js"],"names":["createStore","combineReducers","applyMiddleware","ReduxThunk","allReducers","user","userReducer","store","count","initalState","userInitialState","initialzeStore","state","Object","assign"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,eAAtB,EAAuCC,eAAvC,QAA8D,OAA9D,C,CACA;;AACA,OAAOC,UAAP,MAAuB,aAAvB;AAEA,MAAMC,WAAW,GAAGH,eAAe,CAAC;AAClCI,EAAAA,IAAI,EAAEC;AAD4B,CAAD,CAAnC,C,CAGA;;AACA,MAAMC,KAAK,GAAGP,WAAW,CACvBI,WADuB,EAEvB;AACEI,EAAAA,KAAK,EAAEC,WADT;AAEEJ,EAAAA,IAAI,EAAEK;AAFR,CAFuB,EAMvBR,eAAe,CAACC,UAAD,CANQ,CAAzB,C,CASA;AAEA;AAEA;;AACA,eAAe,SAASQ,cAAT,CAAwBC,KAAxB,EAA+B;AAC5C,QAAML,KAAK,GAAGP,WAAW,CACvBI,WADuB,EAEvBS,MAAM,CAACC,MAAP,CACE,EADF,EAEE;AACEN,IAAAA,KAAK,EAAEC,WADT;AAEEJ,IAAAA,IAAI,EAAEK;AAFR,GAFF,EAMEE,KANF,CAFuB,EAUvBV,eAAe,CAACC,UAAD,CAVQ,CAAzB;AAYA,SAAOI,KAAP;AACD","sourcesContent":["import { createStore, combineReducers, applyMiddleware } from \"redux\";\r\n// applyMiddleware 是 redux 的中间件，构建一些第三方的一些扩展 redux 整个应用体系的方法。\r\nimport ReduxThunk from \"redux-thunk\";\r\n\r\nconst allReducers = combineReducers({\r\n  user: userReducer,\r\n});\r\n// 注意这里的 state 也会发生变化，会自动帮我进行模块区分 { count:initalState, user:userInitialState }\r\nconst store = createStore(\r\n  allReducers,\r\n  {\r\n    count: initalState,\r\n    user: userInitialState,\r\n  },\r\n  applyMiddleware(ReduxThunk)\r\n);\r\n\r\n// console.log(store.getState());\r\n\r\n// action creatore - 有些 action 我们传输的内容会比较多，每次去申明对象，显示这个 type 会比较麻烦，写一个 function 来传递一些参数进去会比较方便一些.\r\n\r\n// 通过这样的方式，让服务端渲染的过程当中，通过调用这个方法来重新生成这个 store，使得每次这个 store 对象都是新的\r\nexport default function initialzeStore(state) {\r\n  const store = createStore(\r\n    allReducers,\r\n    Object.assign(\r\n      {},\r\n      {\r\n        count: initalState,\r\n        user: userInitialState,\r\n      },\r\n      state\r\n    ),\r\n    applyMiddleware(ReduxThunk)\r\n  );\r\n  return store;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}