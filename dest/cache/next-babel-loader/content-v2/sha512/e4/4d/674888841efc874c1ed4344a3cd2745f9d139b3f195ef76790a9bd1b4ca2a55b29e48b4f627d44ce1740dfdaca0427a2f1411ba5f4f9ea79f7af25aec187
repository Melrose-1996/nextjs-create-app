{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { createStore, combineReducers, applyMiddleware } from \"redux\"; // applyMiddleware 是 redux 的中间件，构建一些第三方的一些扩展 redux 整个应用体系的方法。\n\nimport ReduxThunk from \"redux-thunk\"; // const initalState = {\n//   count: 0,\n// };\n\nconst userInitialState = {\n  username: \"jokcy\"\n};\nconst ADD = \"ADD\";\n\nfunction conuntReducer(state = initalState, action) {\n  switch (action.type) {\n    case ADD:\n      // 这边 return 一定要是新的对象，这边 state 默认也是一个对象，不能使用 state.count += 1 (这样我们改变了原来 state 上面的属性，而 state 这个对象是没有变的)，我们通过 return 一个新的对象，这样 state 是有变化的。\n      return {\n        count: state.count + (action.num || 1)\n      };\n\n    default:\n      return state;\n  }\n}\n\nconst UPDATE_USERNAME = \"UPDATE_USERNAME\";\n\nfunction userReducer(state = userInitialState, action) {\n  switch (action.type) {\n    case UPDATE_USERNAME:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        username: action.name\n      });\n\n    default:\n      return state;\n  }\n}\n\nconst allReducers = combineReducers({\n  count: conuntReducer,\n  user: userReducer\n}); // 注意这里的 state 也会发生变化，会自动帮我进行模块区分 { count:initalState, user:userInitialState }\n\nconst store = createStore(allReducers, {\n  count: initalState,\n  user: userInitialState\n}, applyMiddleware(ReduxThunk)); // console.log(store.getState());\n// action creatore - 有些 action 我们传输的内容会比较多，每次去申明对象，显示这个 type 会比较麻烦，写一个 function 来传递一些参数进去会比较方便一些.\n// 注意我们用了 creatore 这个方法了之后，还是可以使用 { type: ADD } 这个方法来触发 action 的。 必须要保证 action 是一个对象\n\nfunction add(num) {\n  return {\n    type: ADD,\n    num\n  };\n}\n\nfunction addAsync(num) {\n  return dispatch => {\n    setTimeout(() => {\n      dispatch(add(num));\n    }, 1000);\n  };\n}\n\nstore.dispatch(add(3));\nstore.dispatch({\n  type: UPDATE_USERNAME,\n  name: \"Melrose\"\n}); // 这个方法的调用实在第一次 dispatch 之前，所以只会监测到第二次 dispatch 发生的变化，这个 api 是让我们监听 store 变化的 api\n\nstore.subscribe(() => {\n  console.log(\"+++++++++++++++++\", store.getState());\n});\nstore.dispatch(addAsync(5)); // console.log(store.getState());\n// 通过这样的方式，让服务端渲染的过程当中，通过调用这个方法来重新生成这个 store，使得每次这个 store 对象都是新的\n\nexport default function initialzeStore(state) {\n  const store = createStore(allReducers, Object.assign({}, {\n    count: initalState,\n    user: userInitialState\n  }, state), applyMiddleware(ReduxThunk));\n  return store;\n}","map":{"version":3,"sources":["C:/Users/pc/Desktop/慕课学习/nextjs-create-app/store/store.js"],"names":["createStore","combineReducers","applyMiddleware","ReduxThunk","userInitialState","username","ADD","conuntReducer","state","initalState","action","type","count","num","UPDATE_USERNAME","userReducer","name","allReducers","user","store","add","addAsync","dispatch","setTimeout","subscribe","console","log","getState","initialzeStore","Object","assign"],"mappings":";;;;;;AAAA,SAASA,WAAT,EAAsBC,eAAtB,EAAuCC,eAAvC,QAA8D,OAA9D,C,CACA;;AACA,OAAOC,UAAP,MAAuB,aAAvB,C,CAEA;AACA;AACA;;AAEA,MAAMC,gBAAgB,GAAG;AACvBC,EAAAA,QAAQ,EAAE;AADa,CAAzB;AAIA,MAAMC,GAAG,GAAG,KAAZ;;AAEA,SAASC,aAAT,CAAuBC,KAAK,GAAGC,WAA/B,EAA4CC,MAA5C,EAAoD;AAClD,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKL,GAAL;AACE;AACA,aAAO;AAAEM,QAAAA,KAAK,EAAEJ,KAAK,CAACI,KAAN,IAAeF,MAAM,CAACG,GAAP,IAAc,CAA7B;AAAT,OAAP;;AACF;AACE,aAAOL,KAAP;AALJ;AAOD;;AAED,MAAMM,eAAe,GAAG,iBAAxB;;AACA,SAASC,WAAT,CAAqBP,KAAK,GAAGJ,gBAA7B,EAA+CM,MAA/C,EAAuD;AACrD,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKG,eAAL;AACE,6CAEKN,KAFL;AAGEH,QAAAA,QAAQ,EAAEK,MAAM,CAACM;AAHnB;;AAMF;AACE,aAAOR,KAAP;AATJ;AAWD;;AAED,MAAMS,WAAW,GAAGhB,eAAe,CAAC;AAClCW,EAAAA,KAAK,EAAEL,aAD2B;AAElCW,EAAAA,IAAI,EAAEH;AAF4B,CAAD,CAAnC,C,CAIA;;AACA,MAAMI,KAAK,GAAGnB,WAAW,CACvBiB,WADuB,EAEvB;AACEL,EAAAA,KAAK,EAAEH,WADT;AAEES,EAAAA,IAAI,EAAEd;AAFR,CAFuB,EAMvBF,eAAe,CAACC,UAAD,CANQ,CAAzB,C,CASA;AAEA;AACA;;AACA,SAASiB,GAAT,CAAaP,GAAb,EAAkB;AAChB,SAAO;AACLF,IAAAA,IAAI,EAAEL,GADD;AAELO,IAAAA;AAFK,GAAP;AAID;;AAED,SAASQ,QAAT,CAAkBR,GAAlB,EAAuB;AACrB,SAAQS,QAAD,IAAc;AACnBC,IAAAA,UAAU,CAAC,MAAM;AACfD,MAAAA,QAAQ,CAACF,GAAG,CAACP,GAAD,CAAJ,CAAR;AACD,KAFS,EAEP,IAFO,CAAV;AAGD,GAJD;AAKD;;AAEDM,KAAK,CAACG,QAAN,CAAeF,GAAG,CAAC,CAAD,CAAlB;AACAD,KAAK,CAACG,QAAN,CAAe;AAAEX,EAAAA,IAAI,EAAEG,eAAR;AAAyBE,EAAAA,IAAI,EAAE;AAA/B,CAAf,E,CAEA;;AAEAG,KAAK,CAACK,SAAN,CAAgB,MAAM;AACpBC,EAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ,EAAiCP,KAAK,CAACQ,QAAN,EAAjC;AACD,CAFD;AAIAR,KAAK,CAACG,QAAN,CAAeD,QAAQ,CAAC,CAAD,CAAvB,E,CAEA;AAEA;;AACA,eAAe,SAASO,cAAT,CAAwBpB,KAAxB,EAA+B;AAC5C,QAAMW,KAAK,GAAGnB,WAAW,CACvBiB,WADuB,EAEvBY,MAAM,CAACC,MAAP,CACE,EADF,EAEE;AACElB,IAAAA,KAAK,EAAEH,WADT;AAEES,IAAAA,IAAI,EAAEd;AAFR,GAFF,EAMEI,KANF,CAFuB,EAUvBN,eAAe,CAACC,UAAD,CAVQ,CAAzB;AAYA,SAAOgB,KAAP;AACD","sourcesContent":["import { createStore, combineReducers, applyMiddleware } from \"redux\";\r\n// applyMiddleware 是 redux 的中间件，构建一些第三方的一些扩展 redux 整个应用体系的方法。\r\nimport ReduxThunk from \"redux-thunk\";\r\n\r\n// const initalState = {\r\n//   count: 0,\r\n// };\r\n\r\nconst userInitialState = {\r\n  username: \"jokcy\",\r\n};\r\n\r\nconst ADD = \"ADD\";\r\n\r\nfunction conuntReducer(state = initalState, action) {\r\n  switch (action.type) {\r\n    case ADD:\r\n      // 这边 return 一定要是新的对象，这边 state 默认也是一个对象，不能使用 state.count += 1 (这样我们改变了原来 state 上面的属性，而 state 这个对象是没有变的)，我们通过 return 一个新的对象，这样 state 是有变化的。\r\n      return { count: state.count + (action.num || 1) };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nconst UPDATE_USERNAME = \"UPDATE_USERNAME\";\r\nfunction userReducer(state = userInitialState, action) {\r\n  switch (action.type) {\r\n    case UPDATE_USERNAME:\r\n      return {\r\n        // 注意我们要保持现在的状态更原先一致\r\n        ...state,\r\n        username: action.name,\r\n      };\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nconst allReducers = combineReducers({\r\n  count: conuntReducer,\r\n  user: userReducer,\r\n});\r\n// 注意这里的 state 也会发生变化，会自动帮我进行模块区分 { count:initalState, user:userInitialState }\r\nconst store = createStore(\r\n  allReducers,\r\n  {\r\n    count: initalState,\r\n    user: userInitialState,\r\n  },\r\n  applyMiddleware(ReduxThunk)\r\n);\r\n\r\n// console.log(store.getState());\r\n\r\n// action creatore - 有些 action 我们传输的内容会比较多，每次去申明对象，显示这个 type 会比较麻烦，写一个 function 来传递一些参数进去会比较方便一些.\r\n// 注意我们用了 creatore 这个方法了之后，还是可以使用 { type: ADD } 这个方法来触发 action 的。 必须要保证 action 是一个对象\r\nfunction add(num) {\r\n  return {\r\n    type: ADD,\r\n    num,\r\n  };\r\n}\r\n\r\nfunction addAsync(num) {\r\n  return (dispatch) => {\r\n    setTimeout(() => {\r\n      dispatch(add(num));\r\n    }, 1000);\r\n  };\r\n}\r\n\r\nstore.dispatch(add(3));\r\nstore.dispatch({ type: UPDATE_USERNAME, name: \"Melrose\" });\r\n\r\n// 这个方法的调用实在第一次 dispatch 之前，所以只会监测到第二次 dispatch 发生的变化，这个 api 是让我们监听 store 变化的 api\r\n\r\nstore.subscribe(() => {\r\n  console.log(\"+++++++++++++++++\", store.getState());\r\n});\r\n\r\nstore.dispatch(addAsync(5));\r\n\r\n// console.log(store.getState());\r\n\r\n// 通过这样的方式，让服务端渲染的过程当中，通过调用这个方法来重新生成这个 store，使得每次这个 store 对象都是新的\r\nexport default function initialzeStore(state) {\r\n  const store = createStore(\r\n    allReducers,\r\n    Object.assign(\r\n      {},\r\n      {\r\n        count: initalState,\r\n        user: userInitialState,\r\n      },\r\n      state\r\n    ),\r\n    applyMiddleware(ReduxThunk)\r\n  );\r\n  return store;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}